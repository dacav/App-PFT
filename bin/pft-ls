#!/usr/bin/perl
#
# Copyright 2014 - Giovanni Simoni
#
# This file is part of PFT.
#
# PFT is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# PFT is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with PFT.  If not, see <http://www.gnu.org/licenses/>.
#
=head1 NAME

pft ls - List objects

=head1 SYNOPSYS

pft ls <class> [options]
pft ls --help

=head1 DESCRIPTION

List objects.

The general usage provides a class of objects to lists. For instance

    pft ls tags

Will list all the tags from all pages and entries.

=head1 CLASSES

=over

=item pages

=item entries

=item tags

=back

=head1 OPTIONS

=over

=item --count

Count the listed items

=item --help | -h

Show this help.

=item --pretty=<fmt>

=over

=item %t -> Title

=item %g -> Comma separated value of tags

=item %a -> Author

=item %e -> Encoding

=item %o -> Comma separated value of option=value pairs

=item %D -> Date in yyyy-mm-dd format if dated, empty string otherwise

=item %y -> Year if dated, empty string otherwise

=item %m -> Month if dated, empty string otherwise

=item %d -> Day if dated, empty string otherwise

=back

=back

=cut

use strict;
use warnings;

use feature qw/say state/;
use Pod::Usage;

use Encode qw/decode encode/;

use App::PFT;
use App::PFT::Struct::Tree;
use App::PFT::Struct::Conf qw/
    cfg_load
    $ROOT
/;

use Getopt::Long;
Getopt::Long::Configure qw/bundling/;

my %opts = (
    pretty => \&title,
);

GetOptions(
    'count!'        => \$opts{count},
    'pretty=s'      => sub { $opts{pretty} = pretty_parse($_[1]) },
    'help|h!'       => sub {
        pod2usage
            -exitval => 1,
            -verbose => 2,
            -input => App::PFT::help_of 'ls',
    },
) or exit 1;

cfg_load App::PFT::findroot -die => 1;

my %classes = (
    tags => \&list_tags,
    pages => \&list_pages,
    entries => \&list_entries,
);

my $cls = shift;
if (defined $cls and my $handle = $classes{$cls}) {
    my $to_show = $handle->();
    if (ref $to_show eq 'HASH') {
        my @keys = sort keys %$to_show;
        say for $opts{count}
            ? map{"$to_show->{$_} $_"} @keys
            : @keys
    }
    elsif (ref $to_show eq 'ARRAY') {
        say for sort @$to_show;
    }
    else { die ref $to_show }
}
else {
    say STDERR "Usage: $App::PFT::Name <class> [options]";
    say STDERR "Available classes:";
    say "  * $_" for keys %classes;
    exit 1;
}

sub tree { state $tree = App::PFT::Struct::Tree->new(basepath => $ROOT) }

sub title { $_->title }

sub pretty_parse {
    my $fmt = shift;
    sub {
        my $out = $fmt;

        $out =~ s/(?<!%)%t/$_->title()/eg;
        $out =~ s/(?<!%)%g/join(',', map{ $_->name } $_->tags())/eg;
        $out =~ s/(?<!%)%a/$_->header->author()/eg;
        $out =~ s/(?<!%)%e/$_->header->encoding()/eg;

        $out =~ s/(?<!%)%o/
            my $h = $_->header->opts();
            join(',', map{ $_ .'='. $h->{$_} } keys %$h )
        /eg;

        $out =~ s/(?<!%)%D/$_->date ? $_->date->repr('-') : ''/eg;
        $out =~ s/(?<!%)%y/$_->date ? $_->date->year() : ''/eg;
        $out =~ s/(?<!%)%m/$_->date ? $_->date->month() : ''/eg;
        $out =~ s/(?<!%)%d/$_->date ? $_->date->day() : ''/eg;

        $out;
    }
}

sub list_tags {
    my %tags;
    for my $c (tree->list_pages, tree->list_entries) {
        $tags{$_->name} ++ for $c->tags;
    }
    \%tags;
}

sub list_pages {
    my $p = $opts{pretty};
    [ map $p->(), tree->list_pages ]
}

sub list_entries {
    my $p = $opts{pretty};
    [ map $p->(), tree->list_entries ]
}
