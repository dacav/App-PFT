#!/usr/bin/perl
#
# Copyright 2014 - Giovanni Simoni
#
# This file is part of PFT.
#
# PFT is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# PFT is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with PFT.  If not, see <http://www.gnu.org/licenses/>.
#
=head1 NAME

pft grab - Grab a file as attachment or picture

=head1 SYNOPSYS

pft grab [options] <file> [<file> ...]

=head1 DESCRIPTION

Grab one or more files as attachments or pictures, put it in the right
place (I<content> directory).

This command outputs the I<markdown> code for linking

If you are using the vim editor, probably you want to call this command
from within it as follows:

    :read ! pft grab [options] file [file...]

=head1 OPTIONS

=over

=item --with-date | -d

Store the file inside a content directory named with the current day. This
is meant to avoid name conflict with previously stored attachments or
pictures having the same name.

=item --picture   | -p

Store the files into the C<I<ROOT>/content/pics> directory and output the
I<markdown> code required to show it as a picture.

Note that no check is performed on the file content.

=item --attach    | -a

Store the files into the C<I<ROOT>/content/attach> directory and output
the I<markdown> code required to link it.

=item --year      | -y

=item --month     | -m

=item --day       | -d

=item --help      | -h

Show this help.

=back

=cut

use strict;
use warnings;
use feature qw/say/;

use Pod::Usage;
use File::Spec::Functions qw/catfile catdir abs2rel/;
use File::Path qw/make_path/;
use File::Basename qw/basename/;
use File::Copy;

use Getopt::Long;
Getopt::Long::Configure ("bundling");

use App::PFT;
use App::PFT::Data::Date;
use App::PFT::Struct::Conf qw/cfg_load $ROOT/;
use App::PFT::Struct::Tree;

use App::PFT::Util qw/slugify/;

use URI;
use LWP::Simple;

my %date;
my %opts = (
    dst     => 'a',
    date    => 0,
);
GetOptions(
    'year|y=i'      => \$date{year},
    'month|m=s'     => \$date{month},
    'day|d=i'       => \$date{day},

    'with-date|D!' => \$opts{date},
    'picture|p!'   => sub { $opts{dst} = 'p' },
    'attach|a!'    => sub { $opts{dst} = 'a' },
    'rename|r=s'   => \$opts{rename},
    'help|h' => sub {
        pod2usage
            -exitval => 1,
            -verbose => 2,
            -input => App::PFT::help_of 'show',
    }
) or exit 1;

@ARGV or do {
    say STDERR 'Any file?';
    exit 1;
};

@ARGV > 1 and $opts{rename} and do {
    say STDERR '--name is not allowed with multiple files';
    exit 1;
};

cfg_load App::PFT::findroot -die => 1;

my $tree = App::PFT::Struct::Tree->new(basepath => $ROOT);

my $dst_base = do {
    my $o = $opts{dst};

    $o eq 'a' ? $tree->dir_attach :
    $o eq 'p' ? $tree->dir_pics :
    die;
};

my $dst_dir = do {
    if ($opts{date} || grep defined @date{qw/year month day/}) {
        catdir(
            $dst_base,
            App::PFT::Data::Date->new(%date, -fill => 'now')->repr('-'),
        )
    } else {
        $dst_base
    }
};

make_path $dst_dir, {verbose => 1};

ITEM: for my $orig_path (@ARGV) {

    # TODO: probably decode $orig_path with the encoding defined in the
    # configuration file.

    my $uri = URI->new($orig_path);
    my $fn = basename $uri->path . $uri->query;

    my $dst_path = catfile($dst_dir, $opts{rename} || $fn);

    if ($uri->has_recognized_scheme) {
        my $status = LWP::Simple::getstore($uri->as_string, $dst_path);
        if ($status < 200 || $status >= 300) {
            say STDERR 'Failed to retrieve ', $uri->as_iri, ': ', $status;
            next ITEM;
        }
    }
    else {
        File::Copy::copy($orig_path, $dst_path) or die "Copy failed: $!";
    }

    my $relative = abs2rel($dst_path, $dst_base);
    say STDOUT
        $opts{dst} eq 'a' ? "[$fn] :attach:$relative" :
        $opts{dst} eq 'p' ? "![$fn](:pic:$relative)" :
        die;
}
