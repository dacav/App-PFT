#!/usr/bin/perl
#
# Copyright 2014-2016 - Giovanni Simoni
#
# This file is part of PFT.
#
# PFT is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# PFT is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with PFT.  If not, see <http://www.gnu.org/licenses/>.
#
=encoding utf8

=head1 NAME

pft make - Build the website

=head1 SYNOPSYS

pft make [options]

=head1 DESCRIPTION

Build the website into the build directory.

=head1 OPTIONS

=over

=back

=cut

use v5.10;

use strict;
use warnings;
use utf8;

use feature qw/say state/;

use Carp;
use Encode;
use Encode::Locale;
use Template::Alloy;

use File::Spec;
use File::Basename qw/dirname/;
use File::Path qw/make_path/;

use PFT::Text;
use PFT::Tree;
use PFT::Util;

my $tree = PFT::Tree->new;
my $conf = $tree->conf;

my($input_enc, $output_enc) = @{$conf}{qw/input_enc output_enc/};
my $template = Template::Alloy->new(
    INCLUDE_PATH => $tree->dir_templates,
    ENCODING => $output_enc,
);
my $dir_build = $tree->dir_build;
my $map = $tree->content_map;

sub node_to_rel {
    my $node = shift;
    confess unless $node;
    my $hdr = $node->header;
    my $k = $node->content_type;

    if ($k =~ /::Blog$/) {(
        'blog',
        sprintf('%04d-%02d', $hdr->date->y, $hdr->date->m),
        sprintf('%02d-%s.html', $hdr->date->d, $hdr->slug),
    )} elsif ($k =~ /::Month$/) {(
        'blog',
        sprintf('%04d-%02d.html', $hdr->date->y, $hdr->date->m),
    )} elsif ($k =~ /::Page$/) {(
        'pages',
        $hdr->slug . '.html',
    )} elsif ($k =~ /::Tag$/) {(
        'tags',
        $hdr->slug . '.html',
    )} elsif ($k =~ /::Picture$/) {(
        'pics',
        $node->content->relpath
    )} elsif ($k =~ /::Attachment$/) {(
        'attachments',
        $node->content->relpath
    )} else { die $k };
}

sub node_to_root {
    my $k = shift->content_type;
    if ($k =~ /::Blog$/) {(
        '..', '..'
    )} elsif ($k =~ /::(Month|Page|Tag)$/n) {(
        '..',
    )} else {
         die "Why going back from $k?"
    };
}

sub node_to_href {
    my($cur_node, $other_node) = @_;
    join('/', node_to_root($cur_node), node_to_rel($other_node));
}

sub node_to_anchor {
    my($cur_node, $other_node) = @_;
    if (defined $other_node) {{
        href => node_to_href(@_),
        slug => $other_node->title,
        date => do {
            my $d = $other_node->date;
            defined $d ? $d->to_hash : undef
        },
    }} else {
        undef
    }
}

sub nodes_to_anchors {
    my $cur_node = shift;
    return undef unless (@_);
    [map node_to_anchor($cur_node, $_), @_]
}

sub print_issues {
    my($node, $issues) = @_;

    return unless keys %$issues;

    my $input_enc = $conf->{input_enc};
    # Input-enc, since we are communicating with user.
    print 'Processing ', encode($input_enc, $node), ":\n";
    for (sort keys %$issues) {
        print "  Unresolved symbols:\n  - ", join("\n  - ",
            map {
                $_->[0]->keyword
                    . '(' . join(', ', $_->[0]->args)
                    . '): '
                    . (defined $_->[1] ? $_->[1] : "Lookup failed")
            }
            $node->symbols_unres
        ), "\n";
    }
}

my %site_info = (
    encoding => $output_enc,
    title => $conf->{site_title},
);

sub site_links {
    my $cur_node = shift;
    pages => nodes_to_anchors($cur_node, $map->pages),
    tags => nodes_to_anchors($cur_node, $map->tags),
    backlog => sub {
        # FIXME: why can't I read param? Need to put 5 manually
        nodes_to_anchors($cur_node, $map->recent_blog(5))
    },
    months_backlog => sub {
        nodes_to_anchors($cur_node, $map->recent_months(5))
    },
}


my $home_node_slug = PFT::Header::slugify($conf->{home_page});
my $home_node;

for my $node ($map->nodes) {
    my %issues;
    my $content = $node->content;

    if ($content->isa('PFT::Content::Entry')) {
        compile_entry($node, $content, \%issues)
    }
    elsif ($content->isa('PFT::Content::Blob')) {
        install_blob($node, $content, \%issues)
    }

    print_issues($node, \%issues);
}

use App::PFT::Util qw/ln/;
my $inject = $tree->dir_inject;
foreach (
    File::Spec->no_upwards(
        map substr($_, 1 + length $inject) => (
            PFT::Util::glob(File::Spec->catfile($inject, '*')),
            PFT::Util::glob(File::Spec->catfile($inject, '.*')),
        )
    )
) {
    my $orig = File::Spec->catfile($inject, $_);
    my $dst = File::Spec->catfile($dir_build, $_);
    ln(encode(locale_fs => $orig) => encode($output_enc, $dst));
}

if (defined $home_node) {
    my $fn = File::Spec->catfile($dir_build, 'index.html');
    open my $f, ">:encoding($output_enc)", $fn
        or croak "Unable to open $fn: $!";
    my $href = join '/', node_to_rel($home_node);
    my $title = $home_node->title;
    print $f
        "<!--\n",
        "    This file is generated automatically. Do not edit, it will be\n",
        "    overwritten. It points browsers to $title\n",
        "-->\n",
        "<meta HTTP-EQUIV=\"REFRESH\" content=\"0; url=$href\">"
    ;
} else {
    print STDERR "Warning: I was not able to find any $home_node_slug page";
}

sub compile_entry {
    my($node, $content, $issues) = @_;

    my $hdr = $node->header;
    if (my @unres = $node->symbols_unres) {
        $issues->{'Unresolved'} = \@unres
    }

    if (!$node->virtual && $hdr->slug eq $home_node_slug) {
        die "There should be no doubles" if defined $home_node;
        $home_node = $node;
    }

    if ($hdr->opts->{hide}) {
        print "Node $node will be hidden\n";
        return;
    }

    my %entry_info = (
        site => \%site_info,
        content => {
            title => $node->title,
            html  => $node->html(sub { node_to_href($node, shift) }),
            tags  => nodes_to_anchors($node, $node->tags),
            date  => do {
                my $d = $node->date;
                defined $d ? $d->to_hash : undef
            },
        },
        links => {
            site_links($node),
            prev     => node_to_anchor($node, $node->prev),
            next     => node_to_anchor($node, $node->next),
            parent   => node_to_anchor($node, $node->month),
            children => nodes_to_anchors($node, $node->children),
        }
    );

    my $out_data;
    $template->process(
        ($hdr->template || $conf->{template}) . '.html',
        \%entry_info,
        \$out_data,
    ) || croak 'Template expansion issue: ', $template->error;

    my $out_path = File::Spec->catfile(
        $dir_build,
        map encode($output_enc, $_) => node_to_rel($node)
    );
    make_path dirname $out_path;
    open(my $fh, ">:encoding($output_enc)", $out_path)
        or croak "Opening $out_path: $!";
    print $fh $out_data;
    close $fh;
}

sub install_blob {
    my($node, $content, $issues) = @_;

    my $out_path = File::Spec->catfile($dir_build, node_to_rel($node));

    ln(encode(locale_fs => $content->path) => encode($output_enc, $out_path));
}
