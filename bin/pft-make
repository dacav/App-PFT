#!/usr/bin/perl
#
# Copyright 2014 - Giovanni Simoni
#
# This file is part of PFT.
#
# PFT is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# PFT is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with PFT.  If not, see <http://www.gnu.org/licenses/>.
#
=encoding utf8

=head1 NAME

pft make - Build the website

=head1 SYNOPSYS

pft make [options]

=head1 DESCRIPTION

Build the website into the build directory.

=head1 OPTIONS

=over

=item --preview | -p

=item --fast | -f

=item --help | -h

=back

=cut

use v5.10;

use strict;
use warnings;
use utf8;

use feature qw/say state/;

use Carp;
use Encode;
use Template::Alloy;

use File::Spec;
use File::Basename qw/dirname/;
use File::Path qw/make_path/;

use PFT::Map;
use PFT::Text;
use PFT::Tree;

my $tree = PFT::Tree->new;
my $conf = $tree->conf;

my $out_enc = $conf->{output_enc};
my $template = Template::Alloy->new(
    INCLUDE_PATH => $tree->dir_templates
);
my $dir_build = $tree->dir_build;
my $map = PFT::Map->new($tree->content);

my $site_root = $dir_build; # TODO: decide preview

sub node_to_rel {
    my $node = shift;
    confess unless $node;
    my $hdr = $node->header;
    my $k = $node->content_type;
    if ($k =~ /::Blog$/) {(
        'blog',
        sprintf('%04d-%02d', $hdr->date->y, $hdr->date->m),
        sprintf('%02d-%s.html', $hdr->date->d, $hdr->slug),
    )} elsif ($k =~ /::Month$/) {(
        'blog',
        sprintf('%04d-%02d.html', $hdr->date->y, $hdr->date->m),
    )} elsif ($k =~ /::Page$/) {(
        'pages',
        $hdr->slug . '.html',
    )} elsif ($k =~ /::Tag$/) {(
        'tags',
        $hdr->slug . '.html',
    )} elsif ($k =~ /::Picture$/) {(
        'pics',
        $node->content->relpath
    )} elsif ($k =~ /::Attachment$/) {(
        'attachments',
        $node->content->relpath
    )} else { die $k };
}

sub node_to_href { join('/', $site_root, node_to_rel(shift)) }

sub node_to_anchor {
    if (my $node = shift) {{
        href => node_to_href($node),
        slug => $node->title,
        date => do {
            my $d = $node->date;
            defined $d ? $d->to_hash : undef
        },
    }} else {
        undef
    }
}

sub nodes_to_anchors {
    return undef unless (@_);
    [map node_to_anchor($_), @_]
}

sub print_issues {
    my($node, $issues) = @_;

    return unless keys %$issues;

    print 'Processing ', encode($out_enc, $node), ":\n";
    for (sort keys %$issues) {
        print "  Unresolved symbols:\n  - ", join("\n  - ",
            map{ $_->keyword . '(' . join(', ', $_->args) . ')' }
            $node->unresolved
        ), "\n";
    }
}

my %site_info = (
    encoding => $out_enc,
    title => $conf->{site_title},
);

my @site_links = (
    pages => nodes_to_anchors($map->pages),
    tags => nodes_to_anchors($map->tags),
    backlog => sub {
        nodes_to_anchors($map->recent_blog(5))
    },
    months_backlog => sub {
        nodes_to_anchors($map->recent_months(5))
    },
);

for my $node ($map->nodes) {
    my %issues;
    my $path_rel = File::Spec->catfile(
        map encode($out_enc, $_),
        node_to_rel $node
    );
    my $out_path = File::Spec->catfile($dir_build, $path_rel);

    if (my @unres = $node->unresolved) {
        $issues{'Unresolved'} = \@unres
    }

    my $content = $node->content;
    if ($content->isa('PFT::Content::Entry')) {
        my $hdr = $node->header;

        my %entry_info = (
            site => \%site_info,
            content => {
                title => $node->title,
                html  => $node->html(\&node_to_href),
                tags  => nodes_to_anchors($node->tags),
                date  => do {
                    my $d = $node->date;
                    defined $d ? $d->to_hash : undef
                },
            },
            links => {
                @site_links,
                prev     => node_to_anchor($node->prev),
                next     => node_to_anchor($node->next),
                parent   => node_to_anchor($node->month),
                children => nodes_to_anchors($node->children),
            }
        );

        my $out_data;
        $template->process(
            ($hdr->template || $conf->{template}) . '.html',
            \%entry_info,
            \$out_data,
        ) || croak 'Template expansion issue: ', $template->error;

        make_path dirname $out_path;
        open(my $fh, ">:encoding($out_enc)", $out_path)
            or croak "Opening $out_path: $!";
        print $fh $out_data;
        close $fh;
    }

    print_issues($node, \%issues);
}
